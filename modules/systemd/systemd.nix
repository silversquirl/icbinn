{
  config,
  lib,
  pkgs,
  inputs,
  ...
}: let
  utils = (import "${inputs.nixpkgs}/nixos/lib/utils.nix" {inherit config lib pkgs;}).systemdUtils;
  cfg = config.systemd;

  inherit
    (utils.lib)
    targetToUnit
    serviceToUnit
    socketToUnit
    timerToUnit
    pathToUnit
    mountToUnit
    automountToUnit
    sliceToUnit
    ;
in {
  options.systemd = {
    package = lib.mkPackageOption pkgs "systemd" {};

    enableStrictShellChecks =
      lib.mkEnableOption ""
      // {
        description = ''
          Whether to run `shellcheck` on the generated scripts for systemd
          units.

          When enabled, all systemd scripts generated by NixOS will be checked
          with `shellcheck` and any errors or warnings will cause the build to
          fail.

          This affects all scripts that have been created through the `script`,
          `reload`, `preStart`, `postStart`, `preStop` and `postStop` options for
          systemd services. This does not affect command lines passed directly
          to `ExecStart`, `ExecReload`, `ExecStartPre`, `ExecStartPost`,
          `ExecStop` or `ExecStopPost`.

          It therefore also does not affect systemd units that are coming from
          packages and that are not defined through the NixOS config. This option
          is disabled by default, and although some services have already been
          fixed, it is still likely that you will encounter build failures when
          enabling this.

          We encourage people to enable this option when they are willing and
          able to submit fixes for potential build failures to Nixpkgs. The
          option can also be enabled or disabled for individual services using
          the `enableStrictShellChecks` option on the service itself, which will
          take precedence over the global setting.
        '';
      };

    units = lib.mkOption {
      description = "Definition of systemd units; see {manpage}`systemd.unit(5)`.";
      default = {};
      type = utils.types.units;
    };

    packages = lib.mkOption {
      default = [];
      type = lib.types.listOf lib.types.package;
      example = lib.literalExpression "[ pkgs.systemd-cryptsetup-generator ]";
      description = "Packages providing systemd units and hooks.";
    };

    targets = lib.mkOption {
      default = {};
      type = utils.types.targets;
      description = "Definition of systemd target units; see {manpage}`systemd.target(5)`";
    };

    services = lib.mkOption {
      default = {};
      type = utils.types.services;
      description = "Definition of systemd service units; see {manpage}`systemd.service(5)`.";
    };

    sockets = lib.mkOption {
      default = {};
      type = utils.types.sockets;
      description = "Definition of systemd socket units; see {manpage}`systemd.socket(5)`.";
    };

    timers = lib.mkOption {
      default = {};
      type = utils.types.timers;
      description = "Definition of systemd timer units; see {manpage}`systemd.timer(5)`.";
    };

    paths = lib.mkOption {
      default = {};
      type = utils.types.paths;
      description = "Definition of systemd path units; see {manpage}`systemd.path(5)`.";
    };

    mounts = lib.mkOption {
      default = [];
      type = utils.types.mounts;
      description = ''
        Definition of systemd mount units; see {manpage}`systemd.mount(5)`.

        This is a list instead of an attrSet, because systemd mandates
        the names to be derived from the `where` attribute.
      '';
    };

    automounts = lib.mkOption {
      default = [];
      type = utils.types.automounts;
      description = ''
        Definition of systemd automount units; see {manpage}`systemd.automount(5)`.

        This is a list instead of an attrSet, because systemd mandates
        the names to be derived from the `where` attribute.
      '';
    };

    slices = lib.mkOption {
      default = {};
      type = utils.types.slices;
      description = "Definition of slice configurations; see {manpage}`systemd.slice(5)`.";
    };

    globalEnvironment = lib.mkOption {
      type = lib.types.attrsOf (
        lib.types.nullOr (lib.types.oneOf [
          lib.types.str
          lib.types.path
          lib.types.package
        ])
      );
      default = {};
      example = {
        TZ = "CET";
      };
      description = ''
        Environment variables passed to *all* systemd units.
      '';
    };
  };

  config = {
    warnings = let
      mkOneNetOnlineWarn = typeStr: name: def:
        lib.optional (
          lib.elem "network-online.target" def.after
          && !(lib.elem "network-online.target" (def.wants ++ def.requires ++ def.bindsTo))
        ) "${name}.${typeStr} is ordered after 'network-online.target' but doesn't depend on it";
      mkNetOnlineWarns = typeStr: defs: lib.concatLists (lib.mapAttrsToList (mkOneNetOnlineWarn typeStr) defs);
      mkMountNetOnlineWarns = typeStr: defs: lib.concatLists (map (m: mkOneNetOnlineWarn typeStr m.what m) defs);
    in
      lib.concatLists (
        lib.mapAttrsToList (
          name: service: let
            type = service.serviceConfig.Type or "";
            restart = service.serviceConfig.Restart or "no";
            hasDeprecated = builtins.hasAttr "StartLimitInterval" service.serviceConfig;
          in
            lib.concatLists [
              (
                lib.optional (type == "oneshot" && (restart == "always" || restart == "on-success"))
                "Service '${name}.service' with 'Type=oneshot' cannot have 'Restart=always' or 'Restart=on-success'"
              )
              (lib.optional hasDeprecated "Service '${name}.service' uses the attribute 'StartLimitInterval' in the Service section, which is deprecated. See https://github.com/NixOS/nixpkgs/issues/45786.")
              (
                lib.optional (service.reloadIfChanged && service.reloadTriggers != [])
                "Service '${name}.service' has both 'reloadIfChanged' and 'reloadTriggers' set. This is probably not what you want, because 'reloadTriggers' behave the same whay as 'restartTriggers' if 'reloadIfChanged' is set."
              )
            ]
        )
        cfg.services
      )
      ++ (mkNetOnlineWarns "target" cfg.targets)
      ++ (mkNetOnlineWarns "service" cfg.services)
      ++ (mkNetOnlineWarns "socket" cfg.sockets)
      ++ (mkNetOnlineWarns "timer" cfg.timers)
      ++ (mkNetOnlineWarns "path" cfg.paths)
      ++ (mkMountNetOnlineWarns "mount" cfg.mounts)
      ++ (mkMountNetOnlineWarns "automount" cfg.automounts)
      ++ (mkNetOnlineWarns "slice" cfg.slices);

    assertions = lib.concatLists (
      lib.mapAttrsToList (
        name: service:
          map
          (message: {
            assertion = false;
            inherit message;
          })
          (lib.concatLists [
            (
              lib.optional
              (
                (builtins.elem "network-interfaces.target" service.after)
                || (builtins.elem "network-interfaces.target" service.wants)
              )
              "Service '${name}.service' is using the deprecated target network-interfaces.target, which no longer exists. Using network.target is recommended instead."
            )
          ])
      )
      cfg.services
    );

    smfh.files = let
      unitLinks = unit: let
        dir = "/etc/systemd/system";
        alias = target: {"${dir}/${target}" = {source = "${dir}/${unit.name}";};};
      in
        [{"${dir}/${unit.name}" = {source = "${unit.unit}/${unit.name}";};}]
        # Create service aliases from aliases option.
        ++ map (name: alias name) (unit.aliases or [])
        # Create .wants, .upholds and .requires symlinks from the wantedBy, upheldBy and requiredBy options.
        ++ map (name: alias "${name}.wants/${unit.name}") (unit.wantedBy or [])
        ++ map (name: alias "${name}.upholds/${unit.name}") (unit.upheldBy or [])
        ++ map (name: alias "${name}.requires/${unit.name}") (unit.requiredBy or []);
    in
      lib.mkMerge (lib.concatMap unitLinks (builtins.attrValues cfg.units));

    # This target only exists so that services ordered before sysinit.target
    # are restarted in the correct order, notably BEFORE the other services,
    # when switching configurations.
    systemd.targets.sysinit-reactivation = {
      description = "Reactivate sysinit units";
    };

    systemd.units = let
      withName = cfgToUnit: cfg: lib.nameValuePair cfg.name (cfgToUnit cfg);
    in
      lib.mapAttrs' (_: withName pathToUnit) cfg.paths
      // lib.mapAttrs' (_: withName serviceToUnit) cfg.services
      // lib.mapAttrs' (_: withName sliceToUnit) cfg.slices
      // lib.mapAttrs' (_: withName socketToUnit) cfg.sockets
      // lib.mapAttrs' (_: withName targetToUnit) cfg.targets
      // lib.mapAttrs' (_: withName timerToUnit) cfg.timers
      // lib.listToAttrs (map (withName mountToUnit) cfg.mounts)
      // lib.listToAttrs (map (withName automountToUnit) cfg.automounts);

    # Generate timer units for all services that have a ‘startAt’ value.
    systemd.timers = lib.mapAttrs (name: service: {
      wantedBy = ["timers.target"];
      timerConfig.OnCalendar = service.startAt;
    }) (lib.filterAttrs (name: service: service.enable && service.startAt != []) cfg.services);
  };
}
